---
layout:       post
title:        "结构聚类与Graph-based图像分割"
description: 
banner: 
categories: 
- Computer Vision
---

<br />

---

高效的基于图的图像分割

文章首先自己定义一种区域边界的度量方法，其度量方法是在基于图的图像表示法之上去定义的。
在这种度量方法之上，我们衍生出来比较高效的图像分割算法。该算法是一种贪婪算法，并且分割结果满足全局属性。

通过上述逻辑关系可以看出，文章定义的度量方法需要比较准确，有一定的物理意义在里面，不然即使算法再高效，度量本身有问题，那么分割出来的图像区域也是不准确的。那么文章自然的可以分为两个部分1）区域度量方法。2）高效分割算法

图像分割的在很多应用中非常重要，是很多高层应用的前提，比如识别、索引等，我们不具体举例。我们认为图像分割的方法有下面这样的特性：

- 能够捕捉到**感知上比较重要**的区域，这通常体现在图像的全局特性方面。这里有两个关键点，一方面要提供感知重要的精准属性，另一方面能够确定给定的分割技术是做什么的。我们认为应该有对分割结果属性的经确定以，这样的方法才能够更好的被理解，进而与其他的方法进行比较。
- 高效，接近图像像素点数量的线性时间复杂度。为了能够实际使用，我们认为分割方法应该与边缘检测或者其他low-level图像处理技术有着相似的时间复杂度，意味着时间复杂度是线性，而且常系数也比较小。比如每一秒能对几帧图像进行分割的算法就能
够处理实时的视频数据。

然而，近几年的一些方法并不能够达成上述两方面要求，哪些方法太慢以致不能实践中使用。相比较而言，本文提到的方法已经因公在大尺度图像数据集应用上。有一些其他的方法可以比较快速的进行图像分割，但是这些方法不能捕捉感知上重要的非局部特性，下文会提到。总而言之，本文在保证效率的同时考虑到了图像全局属性上的感知重要区域。

首先我们来看一幅人造图像，请看图像1
我们人眼会认为这幅图像有三个区域，这个例子能够解释什么是感知重要属性（conceptually important property）。首先，**亮度的变化不应该单独的座位分割区域的衡量标准**。比如图像中左侧渐变区域和右侧的高频噪声区域都有较大的亮度变化，但是我们他们应该被分割成多个区域。因此，**假设一个区域有着接近恒定的或变化很小的亮度是不正确的。**
第二个感知重要属性是**有意义的区域不能单纯的依靠局部划分标准**。还是在图上我们可以看到原因，渐变图像与常量区域的边界上的亮度差值比很多高频区域的差值要小，因此我们得出结论，为了分割一幅图像，我们需要引入一些适应性的或者非局部的衡量标准。
我们在下一节提出的衡量标准会比较两个属性：

- 边界的亮度差值
- 区域内部的邻居像素间的亮度差值

直观上，两个区域的边界上的亮度差值如果比比两个区域中至少一个区域的内部像素差值大的话，那么边界亮度差值会更多的影响我们的感知，这个时候我们说边界亮度差是感知重要的。

###3、基于图的分割
好下面我们来进入正题，基于图的图像分割（Graph-Based Segmentation）。
我们使用基于图的方法来做图像分割，令`\(G=(V,E)\)`表示一个无向图，点集`\(v_i \in V\)`，待分割的元素集合。边`\((v_i,v_j) \in E\)`有一个相应的权重`\(w((v_i,v_j))\)`，是一个非负值，描述两个相邻元素`\(v_i\)`和`\(v_j\)`的不相似度。在图像分割，也就是本文的语境下，V中的元素就是像素点，边就是它的两个像素点（这两个像素点是相邻的）不相似性的某种度量（例如亮度，颜色，运动，位置或者其他局部属性）。在文章的最后我们会讨论比较特殊的边集合和权重函数，不过这里的公式和不相似性度量的方法是独立的，我们可以按照自己的需求定制度量方案，这里讨论的是大框架。

在基于图的方法中，一个分割方案S是V的一个划分，每一个区域(region or component)`\(C \in S\)`对应着图
```\(G^` = (V,E^`)\)```的一个连通区域，其中```\(E^` \subseteq E\)```。有许多方法来衡量一个分割的好坏，大体上我们希望**一个区域内部的元素尽可能相似，不同区域之间的像素尽可能不同**。这意味着同一区域内，相邻两个点的有相对来说比较小的权值，不同区域的相邻两个点的边有大的权值。

####3.1、成对的区域比较预测法
这一节我们首先定义一个预测，D，来估计是否存在一个显著的证据表明有一个边界能将两个区域分割开。就像上文说的，就是对外部的不相似性与内部不相似进行比较，也就是比较inter-component和within component的差值。

我们定义内部不相似性为该区域最小生成树的最大边，`\(MST(C,E)\)`，即：
```\[Int(C) = \mathop {\max }\limits_{e \in MST(C,E)}w(e)\]```
这个方法潜在的直觉是**一个区域C，它保持连通的最低要求是Int(C)这个edge所决定的。**

定义两个区域的不同：区域`\(C_1,C_2 \subseteq V\)`，连接这两个区域的所有边的权值中，最小的那个权值。即，

```\[Dif(C_1,C_2) = \mathop {\min }\limits_{v_i \in C_1 ,v_j \in C_2, (v_i,v_j) \in E}w((v_i,v_j)).\]```
如果两个区域没有连接的边，则令`Dif(C_1,C_2) = \infty`
这个定义理论上可能会有问题，因为它只反映了（或者说只考虑到了）两个区域间权值最小的那条边。在实践中我们发现尽管有显著的局限，但这种度量方式结果颇佳。值得一提的是，改变这个衡量标准也是可以的，比如采用中位数或者其他的分位点，提升对异常值的鲁棒性，但这种改变会使问题编程NP-hard问题。因此一个小小的分割标准的改变会大大改变解决问题的难度。

**区域比较预测法**通过比较`\(Dif(C_1,C_2)\)`和`\(Int(C_1)\)`与`\(Int(C_2)\)`中较小的一个，来判断这两个区域是否有一个边界（换言之这两个区域是否有足够的理由保持两个区域）。

```
\[f(n) =
\begin{cases} 
true,   \mbox {if } \mbox Dif(C_1,C_2) > M Int(C_1,C_2)\\
false,  otherwise 
\end{cases}\]
```
我们引入了一个阈值函数来控制我们希望的外部不相似度与内部不相似度的相差程度。
```\[MInt(C_1,C_2) = min(Int(C_1) + \tau(C_1),Int(C_2) + \tau(C_2))\]```
对于比较小的区域，`\(Int(C)\)`并不能够较好的反应局部特性，比如最极端的情况下，当`\(|C| = 1\)`时，`\(Int(C) = 0\)`。因此我们需要一个跟区域大小相关的阈值函数
`\[\tau (C) = \frac{k}{|C|}\]`
其中`\(|C|\)`表示的是区域C的大小，k是一个常数。越是小的区域，我们越希望较大的外部不相似性。
在实际中，我们可以调整k的取整来获得不同的效果。**当k值很大时，算法倾向于分割出来较大的块，当k值较小时，算法倾向于更细的划分**。

本节最后我们探讨一个比较有趣的话题，就是`\(\tau\)`函数的选取，如果我们改变这个函数，不会对算法的大框架造成影响，而会对分割结果的倾向性有影响。比如我们可以让分割倾向于某一种形状A，令`\(\tau\)`函数在区域不是形状A的时候较大即可。这种形状上的倾向可以比较简单，比如希望正方形的或者扁平状的，也可以比较复杂，是一种特殊的形状。

###分割算法
本节讲解主要的算法部分，怎样利用上述的定义，在基于图的表示方法下，做出高效而准确的分割。算法的核心：
输入是一个图`\(G=(V,E)\)`，有n个点和m个边。输出是一个分割V，分割成`\(S=(C_1,...,C_2).\)`

0. 对E进行排序，生成非递减的序列`\(\pi = (o_1,...,o_m)\)`
1. 从初始分割`\(S^0\)`开始，每一个点`\(v_i\)`自己就是一个区域
2. 对于每一个`\(q = 1,...,m\)`重复步骤3
3. 通过`\(S^{q-1}\)`构建`\(S^q\)`，使用如下的方式：令`\(v_i\)`和`\(v_j\)`表示按顺序排列的第q条边的两个点，比如`\(o_q = (v_i,v_j)\)`。如果`\(v_i\)`和`\(v_j\)`在`\(S^{q-1}\)`中连个不同的区域下，并且`\(w(o_q)\)`比两个区域的内部不相似度都小，那么合并这连个区域，否则什么也不做。用公式来表达就是：令`\(C_{i}^{q-1}\)`是`\(S^{q-1}\)`的一个区域，它包含点`\(v_i\)`；令`\(C_{j}^{q-1}\)`是`\(S^{q-1}\)`的一个区域，它包含点`\(v_j\)`。如果`\(C_{i}^{q-1} \neq C_{j}^{q-1}\)` 并且`\(w(o_q) \leq MInt(C_i^{q-1},C_j^{q-1})\)`，那么通过合并`\(C_{i}^{q-1}\)`和`\(C_{j}^{q-1}\)`我们得到了`\(S^q\)`；否则的话`\(S^q = S^{q-1}\)`
4. 返回`\(S = S^m\)`
